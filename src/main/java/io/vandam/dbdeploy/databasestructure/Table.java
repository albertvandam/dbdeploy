//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.2.11
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2016.04.12 at 07:50:56 PM CAT
//

package io.vandam.dbdeploy.databasestructure;

import javax.xml.bind.annotation.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "table", propOrder = {"column", "m_ignoredDataImportColumns", "primaryKey", "uniqueKeys", "foreignKeys", "checkConstraints", "indexes"})
public final class Table {

    /**
     * The column.
     */
    @XmlElement(required = true)
    private List<Column> column;

    @XmlElement(name = "IgnoreColumnForDataImport")
    private List<String> m_ignoredDataImportColumns;

    @XmlTransient
    private List<String> columnNames;

    /**
     * The primary key.
     */
    private List<String> primaryKey;

    /**
     * The unique keys.
     */
    private List<UniqueKey> uniqueKeys;

    @XmlTransient
    private List<String> uniqueKeyNames;

    /**
     * The foreign keys.
     */
    private List<ForeignKey> foreignKeys;

    @XmlTransient
    private List<String> foreignKeyNames;

    /**
     * The check constraints.
     */
    private List<CheckConstraint> checkConstraints;

    @XmlTransient
    private List<String> checkConstraintNames;

    /**
     * The indexes.
     */
    private List<Index> indexes;

    @XmlTransient
    private List<String> indexNames;

    /**
     * The name.
     */
    @XmlAttribute(name = "name", required = true)
    private String name;

    /**
     * The system name.
     */
    @XmlAttribute(name = "systemName", required = true)
    private String systemName;

    /**
     * The description.
     */
    @XmlAttribute(name = "description", required = true)
    private String description;

    /**
     * Instantiates a new table.
     */
    public Table() {
        // Left for JAXB
    }

    /**
     * Instantiates a new table.
     *
     * @param p_name        the name
     * @param p_systemName  the system name
     * @param p_description the description
     * @throws InvalidLengthException the invalid length exception
     */
    public Table(final String p_name, final String p_systemName, final String p_description)
            throws InvalidLengthException {
        setName(p_name);
        setSystemName(p_systemName);
        setDescription(p_description);
    }

    public List<String> getIgnoredImportColumns() {
        if (null == m_ignoredDataImportColumns) {
            m_ignoredDataImportColumns = new ArrayList<>();
        }

        return m_ignoredDataImportColumns;
    }

    /**
     * Gets the value of the columns property.
     *
     * @return the columns
     */
    public List<Column> getColumns() {
        initialiseColumns();

        return column;
    }

    private void initialiseColumns() {
        if (null == column) {
            column = new ArrayList<>();
        }

        if (null == columnNames) {
            columnNames = new ArrayList<>();
        }

        if (columnNames.size() != column.size()) {
            for (int i = 0; i < column.size(); i++) {
                columnNames.add(i, column.get(i).getSystemName());
            }
        }
    }

    /**
     * Put column.
     *
     * @param p_column the p_column
     */
    public void putColumn(final Column p_column) {
        initialiseColumns();

        int idx = columnNames.indexOf(p_column.getSystemName());
        if (-1 == idx) {
            columnNames.add(p_column.getSystemName());
            idx = columnNames.indexOf(p_column.getSystemName());
        }

        column.add(idx, p_column);
    }

    /**
     * Gets the column.
     *
     * @param p_systemName the system name
     * @return the column
     */
    public Column getColumn(final String p_systemName) {
        initialiseColumns();

        final int idx = columnNames.indexOf(p_systemName);
        if (-1 == idx) {
            return null;
        }

        return column.get(idx);
    }

    /**
     * Gets the value of the primaryKey property.
     *
     * @return possible object is
     */
    public List<String> getPrimaryKey() {
        if (null == primaryKey) {
            primaryKey = new ArrayList<>();
        }

        return primaryKey;
    }

    /**
     * Gets the value of the uniqueKeys property.
     *
     * @return possible object is
     * {@link UniqueKey }
     */
    public Collection<UniqueKey> getUniqueKeys() {
        initialiseUniqueKeys();

        return uniqueKeys;
    }

    private void initialiseUniqueKeys() {
        if (null == uniqueKeys) {
            uniqueKeys = new ArrayList<>();
        }

        if (null == uniqueKeyNames) {
            uniqueKeyNames = new ArrayList<>();
        }

        if (uniqueKeyNames.size() != uniqueKeys.size()) {
            for (int i = 0; i < uniqueKeys.size(); i++) {
                uniqueKeyNames.add(i, uniqueKeys.get(i).getName());
            }
        }
    }

    /**
     * Gets the unique key.
     *
     * @param p_systemName the system name
     * @return the unique key
     */
    UniqueKey getUniqueKey(final String p_systemName) {
        initialiseUniqueKeys();

        final int id = uniqueKeyNames.indexOf(p_systemName);
        if (-1 == id) {
            return null;
        }
        return uniqueKeys.get(id);
    }

    /**
     * Put unique key.
     *
     * @param uniqueKey the unique key
     */
    public void putUniqueKey(final UniqueKey uniqueKey) {
        initialiseUniqueKeys();

        int id = uniqueKeyNames.indexOf(uniqueKey.getName());
        if (-1 == id) {
            uniqueKeyNames.add(uniqueKey.getName());
            id = uniqueKeyNames.indexOf(uniqueKey.getName());
        }

        uniqueKeys.add(id, uniqueKey);
    }

    /**
     * Gets the value of the foreignKeys property.
     *
     * @return possible object is
     * {@link ForeignKey }
     */
    public Collection<ForeignKey> getForeignKeys() {
        initialiseForeignKeys();

        return foreignKeys;
    }

    private void initialiseForeignKeys() {
        if (null == foreignKeys) {
            foreignKeys = new ArrayList<>();
        }

        if (null == foreignKeyNames) {
            foreignKeyNames = new ArrayList<>();
        }

        if (foreignKeyNames.size() != foreignKeys.size()) {
            for (int i = 0; i < foreignKeys.size(); i++) {
                foreignKeyNames.add(i, foreignKeys.get(i).getName());
            }
        }
    }

    /**
     * Gets the foreign key.
     *
     * @param p_systemName the p_system name
     * @return the foreign key
     */
    ForeignKey getForeignKey(final String p_systemName) {
        initialiseForeignKeys();

        final int id = foreignKeyNames.indexOf(p_systemName);
        if (-1 == id) {
            return null;
        }
        return foreignKeys.get(id);
    }

    /**
     * Put foreign key.
     *
     * @param foreignKey the foreign key
     */
    public void putForeignKey(final ForeignKey foreignKey) {
        initialiseForeignKeys();

        int id = foreignKeyNames.indexOf(foreignKey.getName());
        if (-1 == id) {
            foreignKeyNames.add(foreignKey.getName());
            id = foreignKeyNames.indexOf(foreignKey.getName());
        }

        foreignKeys.add(id, foreignKey);
    }

    /**
     * Gets the value of the checkConstraints property.
     *
     * @return possible object is
     * {@link CheckConstraint }
     */
    public Collection<CheckConstraint> getCheckConstraints() {
        initialiseCheckConstraints();

        return checkConstraints;
    }

    private void initialiseCheckConstraints() {
        if (null == checkConstraints) {
            checkConstraints = new ArrayList<>();
        }

        if (null == checkConstraintNames) {
            checkConstraintNames = new ArrayList<>();
        }

        if (checkConstraintNames.size() != checkConstraints.size()) {
            for (int i = 0; i < checkConstraints.size(); i++) {
                checkConstraintNames.add(i, checkConstraints.get(i).getName());
            }
        }
    }

    /**
     * Gets the check constraint.
     *
     * @param p_systemName the p_system name
     * @return the check constraint
     */
    CheckConstraint getCheckConstraint(final String p_systemName) {
        initialiseCheckConstraints();

        final int id = checkConstraintNames.indexOf(p_systemName);
        if (-1 == id) {
            return null;
        }

        return checkConstraints.get(id);
    }

    /**
     * Put check constraint.
     *
     * @param checkConstraint the check constraint
     */
    public void putCheckConstraint(final CheckConstraint checkConstraint) {
        initialiseCheckConstraints();

        int id = checkConstraintNames.indexOf(checkConstraint.getName());
        if (-1 == id) {
            checkConstraintNames.add(checkConstraint.getName());
            id = checkConstraintNames.indexOf(checkConstraint.getName());
        }

        checkConstraints.add(id, checkConstraint);
    }

    /**
     * Gets the indexes.
     *
     * @return the indexes
     */
    public Collection<Index> getIndexes() {
        initialiseIndexes();

        return indexes;
    }

    private void initialiseIndexes() {
        if (null == indexes) {
            indexes = new ArrayList<>();
        }

        if (null == indexNames) {
            indexNames = new ArrayList<>();
        }

        if (indexNames.size() != indexes.size()) {
            for (int i = 0; i < indexes.size(); i++) {
                indexNames.add(i, indexes.get(i).getName());
            }
        }
    }

    /**
     * Gets the index.
     *
     * @param p_systemName the p_system name
     * @return the index
     */
    Index getIndex(final String p_systemName) {
        initialiseIndexes();

        final int id = indexNames.indexOf(p_systemName);
        if (-1 == id) {
            return null;
        }

        return indexes.get(id);
    }

    /**
     * Put index.
     *
     * @param index the index
     */
    public void putIndex(final Index index) {
        initialiseIndexes();

        int id = indexNames.indexOf(index.getName());
        if (-1 == id) {
            indexNames.add(index.getName());
            id = indexNames.indexOf(index.getName());
        }

        indexes.add(id, index);
    }

    /**
     * Gets the value of the name property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     *
     * @param value allowed object is
     *              {@link String }
     * @throws InvalidLengthException the invalid length exception
     */
    public void setName(final String value) throws InvalidLengthException {
        if ((1 > value.trim().length()) || (50 < value.trim().length())) {
            throw new InvalidLengthException("Name must be between 1 and 50 characters");
        }
        name = value.trim();
    }

    /**
     * Gets the value of the systemName property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getSystemName() {
        return systemName;
    }

    /**
     * Sets the value of the systemName property.
     *
     * @param value allowed object is
     *              {@link String }
     * @throws InvalidLengthException the invalid length exception
     */
    public void setSystemName(final String value) throws InvalidLengthException {
        if (10 < value.trim().length()) {
            throw new InvalidLengthException("System Name must be between 1 and 10 characters");
        }

        systemName = value.trim();
    }

    /**
     * Gets the value of the description property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is
     *              {@link String }
     * @throws InvalidLengthException the invalid length exception
     */
    public void setDescription(final String value) throws InvalidLengthException {
        if ((null != value) && (50 < value.trim().length())) {
            throw new InvalidLengthException("Description must be between 0 and 50 characters");
        }
        description = (null == value) ? "" : value.trim();
    }

    @Override
    public boolean equals(final Object obj) {
        if (null == obj) {
            return false;
        }

        if (!Table.class.equals(obj.getClass())) {
            return false;
        }

        final Table other = (Table) obj;

        boolean resp = (null == name) ? (null == other.name) : name.equals(other.name);
        resp &= (null == systemName) ? (null == other.systemName) : systemName.equals(other.systemName);
        resp &= (null == description) ? (null == other.description) : description.equals(other.description);
        resp &= (null == column) ? (null == other.column) : column.equals(other.column);
        resp &= (null == primaryKey) ? (null == other.primaryKey) : primaryKey.equals(other.primaryKey);
        resp &= (null == uniqueKeys) ? (null == other.uniqueKeys) : uniqueKeys.equals(other.uniqueKeys);
        resp &= (null == foreignKeys) ? (null == other.foreignKeys) : foreignKeys.equals(other.foreignKeys);
        resp &= (null == checkConstraints) ? (null == other.checkConstraints) : checkConstraints.equals(other.checkConstraints);
        resp &= (null == indexes) ? (null == other.indexes) : indexes.equals(other.indexes);
        return resp;
    }

    @Override
    public int hashCode() {
        int result = (null != column) ? column.hashCode() : 0;
        result = (31 * result) + ((null != columnNames) ? columnNames.hashCode() : 0);
        result = (31 * result) + ((null != primaryKey) ? primaryKey.hashCode() : 0);
        result = (31 * result) + ((null != uniqueKeys) ? uniqueKeys.hashCode() : 0);
        result = (31 * result) + ((null != uniqueKeyNames) ? uniqueKeyNames.hashCode() : 0);
        result = (31 * result) + ((null != foreignKeys) ? foreignKeys.hashCode() : 0);
        result = (31 * result) + ((null != foreignKeyNames) ? foreignKeyNames.hashCode() : 0);
        result = (31 * result) + ((null != checkConstraints) ? checkConstraints.hashCode() : 0);
        result = (31 * result) + ((null != checkConstraintNames) ? checkConstraintNames.hashCode() : 0);
        result = (31 * result) + ((null != indexes) ? indexes.hashCode() : 0);
        result = (31 * result) + ((null != indexNames) ? indexNames.hashCode() : 0);
        result = (31 * result) + ((null != name) ? name.hashCode() : 0);
        result = (31 * result) + ((null != systemName) ? systemName.hashCode() : 0);
        result = (31 * result) + ((null != description) ? description.hashCode() : 0);
        return result;
    }
}
